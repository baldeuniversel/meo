#!/usr/bin/zsh

:   ' 
    /**
    * @overview This program allows to manage the available packages from the git repository 
    * `https://github.com/baldeuniversel/linux.git` (First of all, this program is written for 
    *                                                the <<Ve-Quantic>> members) .
    * The program also allows to list available packages from the same git repository .
    *
    *
    *
    * @requires The only options supported are [ self-update, install, update, upgrade, remove
    *                                            download, list, list-installed, search, show, 
    *                                            info, --help, --doc, --version ] 
    * && the <<meo>> command has to have at least one option .  Ex: meo self-update
    * && with the options [ install, remove, search, show, download ] you have to give the package(s)
    * && with the options [ self-update, list, update, list-installed, --help, --doc, --version ] 
    *                                                              there is not another parameter
    * && with the options [ upgrade ], you can either upgrade all the installed packages 
    *                                              by `meo` or upgrade target installed packages 
    *                                Ex : meo upgrade    (to upgrade all the installed packages by `meo`) 
    *                                Ex : meo upgrade am-okay    (to upgrade the target installed package)
    *
    * && with the option [ info ], one available (from `https://github.com/baldeuniversel/linux.git`) package 
    *                                                                    can be given . Ex : meo info am-okay
    *
    * && you can not call `meo` program to install it itself . Ex : meo install meo
    *
    *
    *
    * Options :
    * --------
    * @param {string} self-update // This option allows to verify if there is a new version/revision of `meo` 
    *                                program that is ready to upgrade
    *                                Ex : meo self-update
    * 
    * @param {string} install // This option allows installing packages
    *                            Ex : meo install am-okay
    *
    * @param {string} update // This option allows to list the packages ready to upgrade and it also allows to 
    *                           update the list of available packages   
    *                           Ex : meo update
    *
    * @param {string} upgrade // This option allows upgrading the packages ready to upgrade
    *                            Ex : meo upgrade (to upgrade all the installed packages by `meo` program)
    *                            Ex : meo upgrade am-okay (to upgrade the target installed 
    *                                                      package by `meo` program)
    *   
    * @param {string} remove // This option allows removing packages
    *                           Ex : meo remove am-okay
    *
    * @param {string} download // This option allows to download packages
    *                             Ex : meo download am-okay
    *
    * @param {string} list // This option allows to list packages of the git repository
    *                         Ex : meo list
    *                         Note: To have the updated list, you have first of all to execute the command 
    *                               `sudo meo update `
    *
    * @param {string} list-installed // This option allows listing the installed packages from the git repository
    *                                   Ex : meo list-installed
    *
    * @param {string} search // This option allows to search packages from the git repository
    *                           Ex : meo search am-okay
    *
    * @param {string} show // This option allows to have information on the installed packages from the `control` 
    *                         files
    *                         Ex : meo show am-okay

    * @param {string} info // This option allows to get information about a available package from the Github
    *                         repository `https/github.com/baldeuniversel/linux` (since the last execution of 
    *                                                                            ( the command `sudo meo update `)
    *                         Ex : meo info am-okay
    *
    * @param {string} --help // This option allows getting help on the `meo` program
    *                           Ex : meo --help
    *
    * @param {string} --doc // This option allows getting a documentation on `meo` program
    *                          Ex : meo --doc
    *
    * @param {string} --version // This option allows getting the version installed of the `meo` program
    *                              Ex : meo --version
    *
    *
    * @ensure Successfully execution if the preconditions are satisfied. That is to say, with the 
    * above options and the appropriated sequences allowed for these options .
    *
    *
    *
    * @note This program depends of some programs, these programs are required in the global `meo`
    * package .
    *
    *
    *
    * @author <BaldÃ© Amadou> <baldeuniversel@protonmail.com>
    *
    */

    '



set -uo pipefail # To exit the script if there is an error



# Check to see if there is at least one option for `meo` in input
if [[ $# -lt 1 ]]
then
    
    #
    getMeoName=` echo "$0" | awk '{ split($0, array, "/"); print array[length(array)] }' `

    echo "~"
    echo -e "It has to be at least one parameter for the \e[32;1m$getMeoName\e[0m program \U001F9D0 "
    exit 1
fi


# Exclude some sensitive actions 
if ( [[ $USER != "root" ]] ) && ( [[ $1 != "list" ]] && [[ $1 != "list-installed" ]] && [[ $1 != "--version" ]] \
     && [[ $1 != "show" ]] && [[ $1 != "info" ]] && [[ $1 != "search" ]] && [[ $1 != "--doc" ]] && [[ $1 != "--help" ]] )
then
    echo "~"
    echo -e "Only the root/admin has the right to execute this \e[32;1mmeo\e[0m action \U001F6A7 "
    exit 1
fi



# Declaration variables
listOfParams=("self-update" "install" "update" "upgrade" "remove" "download" \
    "list" "list-installed" "search" "show" "info" "--help" "--doc" "--version")

counterOption=0



### Check the input options -> start tag[p0]
#
for optionUP in ${listOfParams[@]}
do
    if [[ $1 != $optionUP ]]
    then
        counterOption=$(( counterOption + 1 ))
    fi

    #
    if [[ $counterOption -eq 14  ]]
    then
        echo "~"
        echo -e "Unknown `tput setaf 3; tput bold`$1` tput sgr0 ` option \U001F9D0 "
        exit 1
    fi
done
#
if ( [[ $1 == "self-update" ]] || [[ $1 == "self-upgrade" ]] || [[ $1 == "self-remove"  ]] || [[ $1 == "list" ]] \
     || [[ $1 == "list-installed" ]] || [[ $1 == "--doc" ]] || [[ $1 == "--help" ]] || [[ $1 == "--version" ]] ) \
     && ( [[ $# -gt 1 ]] )
then
    echo "~"
    echo -e "There can only be one parameter when the \e[32;1m$1\e[0m option is invoked \U001F9D0 "
    exit 1
fi
#
if ( [[ $1 == "install" ]] || [[ $1 == "remove"  ]] || [[ $1 == "search"  ]] || [[ $1 == "show"  ]] || \
     [[ $1 == "download"  ]] ) && ( [[ $# -lt 2  ]] )
then
    echo "~"
    echo -e "There have to be at least two parameters when the \e[32;1m$1\e[0m option is invoked \U001F9D0 "
    exit 1
fi
#
if ( [[ $1 == "info" ]] && [[ $# -ne 2 ]] )
then
    echo "~"
    echo -e "There have to be two parameters when the \e[32;1m$1\e[0m option is invoked \U001F9D0 "
    exit 1
fi

### Check the input options -> end tag[p0]





### Prepare some necessary directories or files -> start tag[c0]

# Declaration variables
getPersonalUserDir=$HOME

meoRootDir="/usr/lib/meo"

meoLibraryDir="$meoRootDir/library"

meoListInstalledPkgs="$meoLibraryDir/info/list-installed-packages"
meoListAvailablePkgs="$meoLibraryDir/info/list-available-packages"

meoListInstalledPkgsPure="$meoLibraryDir/info/list-installed-packages-pure"
meoListAvailablePkgsPure="$meoLibraryDir/info/list-available-packages-pure"

meoPackages="$meoLibraryDir/packages"

meoDocumentationDir="$meoRootDir/documentation"

getThisPid="$$"

meoTmp="/tmp/.$USER/meo/$getThisPid"
meoTmpDirGithub="$meoTmp/github"

fileCodeReturnCommand="$meoTmp/code-return-command"

### Prepare some necessary directories or files -> end tag[c0]





:   '
/**
* @overview The `truncateFileData` allows to remove the data that contains a file
*
* @param {string} $1 // The file that has to be truncated
*
*/
    '
function truncateFileData
{
    # Declaration variables
    local getTheFile="$1"



    # Remove the data contained in the target file
    if [[ -e "$getTheFile" ]] && [[ -f "$getTheFile" ]]
    then
        truncate -s 0 "$getTheFile" 2> /dev/null
    fi
}





:   '
/**
* @overview The `removeDirFile` allows to remove a directory or file
*
* @param {string} $@ // The files or directories to remove
*
*/
    '
function removeDirFile
{
    # Declaration variables
    local getTheDirFile="$@"



    # Remove the file or directory if it exists
    for dirFile in "$@"
    do
        if [[ -e "$dirFile" ]]
        then
            rm -fr "$dirFile" 2> /dev/null
        fi
    done
}





:   '
/**
* @overview The `alertNonEffectiveAction` function allows to raise exceptions .
*
* @param {string} $1 // A file where the code of return of the `meo` program will be sent .
*/
    '
function alertNonEffectiveAction 
{
    # Declaration variables
    local getPathOfFileForReturnLastCommand="$1"
    local getNumberOfLine=0



    if [[ $# -eq 1 ]] && [[ "$getPathOfFileForReturnLastCommand" != "none" ]]
    then
        if [[ -e "$getPathOfFileForReturnLastCommand" ]]
        then
            getNumberOfLine=` wc -l "$getPathOfFileForReturnLastCommand" | cut -d " " -f1 | tr -d "[[:space:]]" `

            #
            if [[ $getNumberOfLine -gt 0 ]]
            then
                echo "~"
                echo -en "Something wrong \U001F9D0, please make sure you have a permission to \nexecute the \e[32;1mmeo\e[0m program "

                # Call the function
                $( truncateFileData "$getPathOfFileForReturnLastCommand" )

                #
                setterm --cursor on
                exit 1 
            fi
        fi
    fi
}





:   '
/**
* @overview The `refreshAvailablePkgsFile` function allows to update the files that contain the 
* list of available packages from the Github repository
*/
    '
function refreshAvailablePkgsFile
{
    
    # Declarations variables
    local getURL="https://github.com/baldeuniversel/linux.git"
    local getBranch="current-version-pkgs" 
    local getFileCurrentVersionPkg="current-version-pkgs"


    #
    if [[ ! ( -e "$meoTmpDirGithub" ) ]]
    then
        mkdir -p $meoTmpDirGithub
    fi
   
    # Check if there is internet connection
    curl ifconfig.me &> /dev/null   
    #
    if [[ $? -ne 0 ]]
    then
        echo "~"
        echo -e "Your internet connection seems not to be established \U001F30D"
        exit 1
    fi


    # Call the function
    $( removeDirFile "$meoTmpDirGithub/linux" )

    # Clone the git repository
    git clone --branch "$getBranch" --single-branch --depth 1 \
        "$getURL" "$meoTmpDirGithub/linux" 2> /dev/null
    
    #
    if [[ $? -eq 0 ]]
    then
    
        # Action to save in another files the content of the file that contents the available packages  
        find "$meoTmpDirGithub/linux"  -name "$getFileCurrentVersionPkg" -type f -exec \
            cat {} \; | grep -A 2 "package" | awk '{ gsub(/^[[:space:]]*|,|--/, "");  print }' > $meoListAvailablePkgsPure
    
        #
        find "$meoTmpDirGithub/linux"  -name "$getFileCurrentVersionPkg" -type f -exec \
            cat {} \; | grep -A 2 "package" | awk '{ gsub(/^[[:space:]]*|,|--/, ""); print }' | \
            awk -F ": " 'length($0) > 3 && NF > 0 {printf "\033[1;036m%s\033[0m: \033[1;32m%s\033[0m\n", $1, $2}; \
            length($0) < 3 && NF <= 0 {print}' > $meoListAvailablePkgs
    fi

}





:   '
/**
* @overview `clonePersonalGit` allows to clone a git repository (see where the clone is putted)
*/
    '
function clonePersonalGit
{
    # Declaration variable
    local getURL="https://github.com/baldeuniversel/linux.git"



    # Check if there is internet connection
    curl ifconfig.me &> /dev/null   
    #
    if [[ $? -ne 0 ]]
    then
        echo "~"
        echo -e "Your internet connection seems not to be established \U001F30D"
        exit 1
    fi


    # Call the function
    $( removeDirFile "$meoTmpDirGithub/linux" )

    # Clone the git repository
    git clone --branch main --single-branch --depth 1 "$getURL" "$meoTmpDirGithub/linux" 2> /dev/null

}





:   '
/**
* @overview `cloneSingleBranchGit` allows to clone a single branch via a git 
* repository (see where the clone is putted)
*
* @param {string} $1 // The branch to clone
*/
    '
function cloneSingleBranchGit
{
    # Declaration variables
    local getTheBranch="$1"
    local getURL="https://github.com/baldeuniversel/linux.git"



    # Check if there is internet connection
    curl ifconfig.me &> /dev/null   
    #
    if [[ $? -ne 0 ]]
    then
        echo "~"
        echo -e "Your internet connection seems not to be established \U001F30D"
        exit 1
    fi


    # Call the function
    $( removeDirFile "$meoTmpDirGithub/linux" )

    #
    if [[ ! -e "$meoTmpDirGithub" ]]
    then
        #
        mkdir -p "$meoTmpDirGithub" 2> /dev/null 
        
        #
        if [[ $? -ne 0 ]]
        then
            #
            echo "~"
            echo -e "Something is wrong, make sure you have the permission to write to the [ /tmp ] directory \U001F9D0 "

            exit 1
        fi
    fi

    # Clone the git repository
    git clone --branch "$getTheBranch" --single-branch --depth 1 "$getURL" \
        "$meoTmpDirGithub/linux" 2> /dev/null

}





:   '
/**
* @overview The `storeInslalledPkg` function allows to store the installed packages
* on the `list-available-packages` file 
*
*
* @param {string} $1 // The file where the package information is located
*
* @param {string} $2 // The program to install 
*/
    '
function storeInslalledPkg
{

    # Declaration variables
    local counterLine=0
    local fileAction="$meoTmpDirGithub/package-info"
    local getNameOfPkg=""
    local getVersionOfPkg=""
    local getPkgHash=""
    local getTheFileListPkg="$1" 
    local getTheProgram="$2"
    

    #
    getTheFileListPkg=` cat $getTheFileListPkg | grep -w -A 2 -- "package" | \
        awk '{ gsub(/^[[:space:]]*|,|--/, ""); print }' | \
        awk -v pkgName=$getTheProgram -F ' '  '$2 == pkgName {counter=3} { { if (counter && counter-- > 0) {print} } }' `
    
    #
    if [[ ! -e "$meoTmpDirGithub" ]]
    then
        mkdir -p "$meoTmpDirGithub" 2> /dev/null
    fi

    # Put the content of the variable in the target file
    echo "$getTheFileListPkg" > $fileAction



    # Create the directory and the files where some info about the installed packages will be save
    if [[ ! -e "$meoLibraryDir/info" ]]
    then
        
        mkdir -p "$meoLibraryDir/info" 2> /dev/null
    fi
    #
    if [[ ! -e "$meoListInstalledPkgsPure" ]]
    then
        touch "$meoListInstalledPkgsPure" 2> /dev/null
    fi
    


    # Action to store the info about the package
    while IFS= read -r lineFile
    do
        # Get the name of the package
        if [[ $counterLine -eq 0 ]]
        then
            #
            getNameOfPkg=` echo "$lineFile" | awk '{ split($0, array, ": " ); print array[length(array)] }' | tr -d "[[:space:]]" `

            #
            counterLine=$(( counterLine + 1 ))

        # Get the version
        elif [[ $counterLine -eq 1 ]]
        then
            #
            getVersionOfPkg=` echo -e $lineFile | awk '{ split($0, array, ": " ); print array[length(array)] }' | tr -d "[[:space:]]" `

            #
            counterLine=$(( counterLine + 1 ))
        
        # Get the hash (md5sum)
        elif [[ $counterLine -eq 2 ]]
        then
            #
            getPkgHash=` echo -e $lineFile | awk '{ split($0, array, ": " ); print array[length(array)] }' | tr -d "[[:space:]]" `

            #
            counterLine=$(( counterLine + 1 ))
        fi
        


        #
        if [[ -e "$meoListInstalledPkgsPure" ]] && [[ $counterLine -eq 3 ]]
        then
           
            # Check if the package does not exist in the target file `$meoListInstalledPkgsPure`, then ...
            if [[ ! ` cat $meoListInstalledPkgsPure | cut -d ":" -f 1 | grep -w "$getTheProgram" ` ]]
            then
                #
                echo -e "$getNameOfPkg : v($getVersionOfPkg) , hash(md5sum) : $getPkgHash" >> \
                    $meoListInstalledPkgsPure 2> /dev/null

            # Check the version, then ...
            else
                #
                if [[ ! ` cat $meoListInstalledPkgsPure | cut -d ":" -f 2 | grep -w "$getVersionOfPkg" ` ]]
                then
                    # Get the line number of the package via the given file `$meoListInstalledPkgsPure` 
                    getLineNbPkgOldVersion=` grep -nw "$getNameOfPkg"  $meoListInstalledPkgsPure | cut -d ":" -f 1 `

                    # Get the version of the package via the given file ...
                    getTheOldVersion=` sed -n "$getLineNbPkgOldVersion p" $meoListInstalledPkgsPure | \
                        cut -d ":" -f2 | cut -d "," -f1 | cut -d "(" -f2 | cut -d ")" -f 1 `

                    # Substitute the old version by the new one 
                    sed -i "$getLineNbPkgOldVersion s/$getTheOldVersion/$getVersionOfPkg/" $meoListInstalledPkgsPure 
                fi
            fi
        fi

    done < $fileAction

}





:   '
/**
* @overview The `isPackageInstalled` allows to verify if the package is installed
*
* @param {string} $1 // The package to verify
*
* @return {string} // A `true` string will be returned if the package exists, else
*                     `false` string will be returned
*
*/
    '
function isPackageInstalled
{
    # Declaration variables
    local getPkg="$1"



    which ` echo "$getPkg" ` &> /dev/null

    #
    if [[ $? -eq 0 ]]
    then
        echo "true"
    else
        echo "false"
    fi
    
}





:   '
/**
* @overview The function `isPackageAvailable` allows to verify if a given package exists in the
* `list-available-packages` file
* 
* @param {string} $1 // The package to verify the existence
* @param {int} $2 // The counter (for the iteration)
* @param {string | optional} $2 // A parameter flag allowing to call the function  `refreshAvailablePkgsFile`
*                               or not
*
*/
    '
function isPackageAvailable
{
    # Declaration variables
    local getPackage=""
    local getFirstParam="$1"
    local getSecondParam="$2"
    local getThirdParam="$3"

    

    #
    if [[ $getSecondParam -lt 1 ]] && [[ $getThirdParam == "yes" ]]
    then
        # Call the function
        $( refreshAvailablePkgsFile )
    fi


    #
    if [[ -e "$meoListAvailablePkgs" ]]
    then
        #
        getPackage=` cat $meoListAvailablePkgsPure | cut -d ":" -f 2 | tr -d "[ \t]+" | grep -w -- "^$getFirstParam$" `

        #
        if [[ -n "$getPackage" ]]
        then
            echo "true"
        else
            echo "false"
        fi
    fi
}





:   '
/**
* @overview The `isNewVersionOfPkgAvailable` allows to verify if a new version of
* a installed package is available
*
* @param {string} $1 // The package to examine
*
* @return {string} // A `true` string will be returned if a new version is available,
* else `false` value will be returned
*
*/
    '
function isNewVersionOfPkgAvailable
{
    # Declaration variables
    local getPkg="$1"
    local getDebPkg=""



    #
    if [[ -e "$meoListAvailablePkgsPure" ]]
    then
        #
        getPkgRefreshVersion=` cat $meoListAvailablePkgsPure | cut -d ":" -f2 | tr -d "[ \t]+" | \
            grep -w -A3 -- "^$getPkg$" | head -n 2 | tail -n 1 `

        getPkgVersionPkgInstalled=` $getPkg --version 2> /dev/null `

            
        # Verify the match versions, then do ...
        if [[ ` echo "$getPkgRefreshVersion" | tr -d "[[:space:]]" ` == \
            ` echo "$getPkgVersionPkgInstalled" | tr -d "[[:space:]]" ` ]]
        then
            echo "false"
        else
            echo "true"
        fi
    fi
}





:   '
/**
* @overview The `isNewRevisionOfPkgAvailable` allows to verify if a new version of
* a installed package is available
*
* @param {string} $1 // The package to examine
*
* @return {string} // A `true` string will be returned if a new revision is available,
* else `false` value will be returned
*
*/
    '
function isNewRevisionOfPkgAvailable
{

    # Declaration variables
    local getPkg="$1"
    local getDebPkg=""



    #
    if [[ -e "$meoListAvailablePkgsPure" ]]
    then
        #
        getRefreshRevisionPkgHash=` cat $meoListAvailablePkgsPure | cut -d ":" -f2 | tr -d "[ \t]+" | \
            grep -w -A3 -- "^$getPkg$" | head -n 3 | tail -n 1 `

        getHashPkgInstalled=` cat $meoListInstalledPkgsPure | awk -F '[: ]' -v getPkg="$getPkg" '$1 == getPkg {print}' | \
            cut -d "," -f 2 | cut -d ":" -f 2 | tr -d "[ \t]" `

            
        # Verify the match versions, then do ...
        if [[ ` echo "$getRefreshRevisionPkgHash" | tr -d "[[:space:]]" ` == \
            ` echo "$getHashPkgInstalled" | tr -d "[[:space:]]" ` ]]
        then
            echo "false"
        else
            echo "true"
        fi
    fi

}





:   '
/**
* @overview The `spinnerAnimation` function allows to make animations while a process is in progress
*
* @param {int} $1 // The pid of the process 
*/
    '
function spinnerAnimation
{
  
    # Declaration variables
    local pidCmd=$1
    local delay=0.3
    local getRandValue=` shuf -i 1-5 -n 1 `
    
    local spinString=""
    local spinStringA="â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â "
    local spinStringB="â—°â—³â—²â—±â—°â—³â—²â—±" 
    local spinStringC="â˜¼â˜€â˜â˜‚â˜ƒâ˜„â˜½â˜¾"
    local spinStringD="â—´â—·â—¶â—µâ—´â—·â—¶â—µ"
    local spinStringE="â™šâ™›â™œâ™â™žâ™Ÿ"
    

    local infotext="\e[36;1mwait...\e[0m \U00270B \U001F449 â³ "
    local firstChar=""


  
    ### Choice the spin string -> start tag[c0]

    if [[ $getRandValue -eq 1 ]]
    then
        #
        spinString=$spinStringA

    elif [[ $getRandValue -eq 2 ]]
    then
        #
        spinString=$spinStringB

    elif [[ $getRandValue -eq 3 ]]
    then
        #
        spinString=$spinStringC
        
    elif [[ $getRandValue -eq 4 ]]
    then
        #
        spinString=$spinStringD

    elif [[ $getRandValue -eq 5 ]]
    then
        #
        spinString=$spinStringE
    fi

    ### Choice the spin string -> start tag[c0]



    #
    trap "setterm --cursor on" SIGINT
  
    #
    setterm --cursor off

    echo "~"
  


    # Animation 
    while [[ ` ps -p "$pidCmd" | grep -- "$pidCmd" ` ]]
    do

      firstChar=${spinString#?}

      echo -en "$infotext $spinString"

      spinString=$firstChar${spinString%"$firstChar"}

      sleep $delay

      echo -ne "\r"

    done

    #
    echo -ne "\e[36;1mwait...\e[0m \U00270B \U001F449 âŒ› $spinString \r"

    #
    echo ""
    echo ""

    #
    setterm --cursor on

}





:   '
/**
* @overview The `removeGitDownloadGitAction` allows to remove files/dirs created during operations
*
*/
    '
function removeGitDownloadGitAction
{
    # Remove the content the given content 
    if [[ -e "$meoTmpDirGithub/linux"  ]]
    then
        rm -rf "$meoTmpDirGithub/linux" 2> /null
    fi

    # Remove files/dirs
    if [[ -e "$meoTmpDirGithub/github-action"  ]]
    then
        rm -rf "$meoTmpDirGithub/github-action" 2> /null
    fi
}





:   '
/**
* @overview The `createDirPackageToInstall` function allows to create a directory where the packages
* to install will be moved .
*
* @return {string} // The created directory will be returned
*/
    '
function createDirPackageToInstall
{

    # Declaration variables
    local getDirPkgToInstall="/tmp/.$USER/meo/package-to-install"



    #
    if [[  ! -e "$getDirPkgToInstall"  ]]
    then
        #
        mkdir -p "$getDirPkgToInstall" 2> /dev/null

        if [[ $? -ne 0 ]]
        then
            echo "~"
            echo -e "Something is wrong, make sure you have the permission to write to the [ /tmp ] directory \U001F9D0 "

            exit 1
        fi
    else
        
        #
        rm -rf "$getDirPkgToInstall" 2> /dev/null
        
        mkdir -p "$getDirPkgToInstall" 2> /dev/null

        if [[ $? -ne 0 ]]
        then
            echo "~"
            echo -e "Something is wrong, make sure you have the permission to write to the [ /tmp ] directory \U001F9D0 "

            exit 1
        fi
    fi


    # Return the directory
    echo "$getDirPkgToInstall"

}





:   '
/**
* @overview The `getNewVersionPkg` allows to get the new version of a program from a defined file 
*
* @param {string} $1 // The name of the package
*
* @return {string} // The version of the given package will be returned
*/
    '
function getNewVersionPkg
{
    # Declaration variables
    local getTheNewVersionPkg=""
    local getTheCurrentVersionFile="$meoListAvailablePkgsPure"
    local getNameOfPkg="$1"

    #
    if [[ -e "$getTheCurrentVersionFile" ]]
    then
        #
        getTheNewVersionPkg=` cat $getTheCurrentVersionFile | grep -A 2 -w $getNameOfPkg | head -n 2 \
            | grep -w "version" | tail -n 1 | cut -d ":" -f 2 | tr -d "[[:space:]]" `

        # Display/return
        echo "$getTheNewVersionPkg"
    else
        echo "~"
        echo -e "Something is wrong, a missing file \U001F9D0. Please reinstall \e[1;032mmeo\e[0m program "

        exit 1
    fi
}





:   '
/**
* @overview The `getNewHashPkg` allows to get the new hash of a program from a defined file 
*
* @param {string} $1 // The name of the package
*
* @return {string} // The hash of the given package will be returned
*/
    '
function getNewHashPkg
{
    # Declaration variables
    local getTheNewHashPkg=""
    local getTheCurrentVersionFile="$meoListAvailablePkgsPure"
    local getNameOfPkg="$1"

    #
    if [[ -e "$getTheCurrentVersionFile" ]]
    then
        #
        getTheNewHashPkg=` cat $getTheCurrentVersionFile | grep -A 3 -w "$getNameOfPkg" | tail -n 2 \
            | grep -w -- "pkg-md5sum" | cut -d ":" -f 2 | tr -d "[[:space:]]" `
        
        # Display/return
        echo "$getTheNewHashPkg"
    else
        echo "~"
        echo -e "Something is wrong, a missing file \U001F9D0. Please reinstall \e[1;032mmeo\e[0m program "

        exit 1
    fi
}





:   '
/**
* @overview The function `colorElem` allows to color strings
*
* @param {string} $1 // The input string to color
*/
    '
function colorElem
{
    # Declaration variables
    getTheString="$1"

    echo -e "\033[36m$getTheString\033[0m"
}





# Create some working dirs 
if [[ ! ( -e "$meoTmp" ) ]]
then
    mkdir -p "$meoTmp" 2> /dev/null
fi
#
if [[ ! ( -e "$meoTmpDirGithub" ) ]]
then
    mkdir -p "$meoTmpDirGithub" 2> /dev/null
fi 

# Trap some commands
trap 'rm -r "$meoTmp" 2> /dev/null'  EXIT 
trap 'rm -r "$meoTmp" 2> /dev/null'  SIGINT SIGTERM





### Action based to the `meo` itself -> start tag[s0]

if [[ $1 == "self-update" ]] && [[ $# -eq 1 ]]
then
    
    # Declaration variables
    getMeoRefreshVersion=""
    getMeoRefreshVersionHash=""
    getMeoVersionPkgInstalledHash=""
    getDebPkg=""
    
    getURLPkg="https://github.com/baldeuniversel/linux/tree/main/packages"
    getMeoVersionPkgInstalled=` meo --version `
    getPkg="meo"
    fieldAlgoHash="pkg-md5sum"
    getMeoDebDir="/usr/lib/meo/library/packages-info/meo/deb"



    # Call the function
    refreshAvailablePkgsFile &

    # Call the function and give the `pid` of the last command 
    spinnerAnimation $!

    #
    if [[ -e "$getMeoDebDir" ]]
    then
        # Get the meo package after having downloading it 
        getDebPkg=` find "$getMeoDebDir" -name "$getPkg*.deb" -type f `

        # Get the hash of the package
        getMeoVersionPkgInstalledHash=` md5sum "$getDebPkg" | cut -d " " -f 1 2> /dev/null `

    else
        echo "~"
        echo "Something is wrong, a $getPkg deb package is missing \U001F9D0, please reinstall the \e[32;1m$getPkg\e[0m program" 

        # Call the function
        removeGitDownloadGitAction

        exit 1
    fi
    


    #
    if [[ -e "$meoListAvailablePkgsPure" ]]
    then
        
        #
        getMeoRefreshVersion=` cat $meoListAvailablePkgsPure | awk 'BEGIN { counter=0 } /\<meo\>/ \
            {counter=3} { if ( counter && counter > 0) { print; counter-- } }' | \
                awk '/\<version\>/ {FS=": "; print $2} ' `

        #
        getMeoRefreshVersionHash=` cat $meoListAvailablePkgsPure | awk 'BEGIN { counter=0 } /\<meo\>/ \
            {counter=3} { if ( counter && counter > 0) { print; counter-- } }' | \
                awk '/\<pkg-md5sum\>/ {FS=": "; print $2} ' ` 


        # Verify the match versions, then do ...
        if ( [[ ` echo "$getMeoRefreshVersion" | tr -d "[[:space:]]" ` == \
            ` echo "$getMeoVersionPkgInstalled" | tr -d "[[:space:]]" ` ]] ) \
            && ( [[ ` echo "$getMeoRefreshVersionHash" | tr -d "[[:space:]]" ` == \
            ` echo "$getMeoVersionPkgInstalledHash" | tr -d "[[:space:]]" ` ]] )
        then
            echo "~"
            echo -e "The job is clean, \e[32;1m$getPkg\e[0m program is up to date \U002705 "


            # Call the function
            removeGitDownloadGitAction

            exit 0

        elif [[ ` echo "$getMeoRefreshVersionHash" | tr -d "[[:space:]]" ` != \
            ` echo "$getMeoVersionPkgInstalledHash" | tr -d "[[:space:]]" ` ]]
        then
            echo "~"
            echo -e "A new revision \U001F4DD of the \e[032;1m$getPkg\e[0m program is available, hash-md5sum \c" 
            echo -e "(\e[1;032m$getMeoRefreshVersionHash\e[0m) ."

            echo ""
            echo -e "Go to this Github \e[1;4;032m$getURLPkg\e[0m repository to" 
            echo -e "download the \e[032;1m$getPkg\e[0m program or download the \e[032;1m$getPkg\e[0m program via the "
            echo -e "command -> \e[036;1msudo $getPkg download $getPkg\e[0m , then install it ."


            # Call the function
            removeGitDownloadGitAction

            exit 0
        else
            echo "~"
            echo -e "A new version ($getMeoRefreshVersion) \e[1;036m â¬† \e[0m for the \e[032;1m$getPkg\e[0m program is available ."
            echo ""
            echo -e "Go to this Github \e[1;4;032m$getURLPkg\e[0m repository" 
            echo -e "to download the \e[032;1m$getPkg\e[0m program or download the \e[032;1m$getPkg\e[0m program via the "
            echo -e "command -> \e[036;1msudo $getPkg download $getPkg\e[0m , then install it ."

            # Call the function
            removeGitDownloadGitAction
            
            exit 0
        fi
    else 
        echo "~"
        echo "Something is wrong, a file is missing \U001F9D0, please reinstall the \e[32;1m$getPkg\e[0m program"

        # Call the function
        removeGitDownloadGitAction

        exit 1
    fi
fi

### Action based to the `meo` itself -> end tag[s0]





### Action based on the `install` option -> start tag[i1]

if [[ $1 == "install" ]] && [[ $# -gt 1 ]]
then
    
    # Declaration variables
    flagPackageFound=""
    flagPackageInstalledFound=""

    getDebPkg=""
    getDirPkgToInstall=""
    getPkgMng="meo"
    pkgDirectoryInMng="/usr/lib/meo/library/packages-info"
    
    counterInstalledPkg=0
    counterCloneGit=0
    counterNotFoundPkg=0
    counterFlagMng=0
    counterAlreadyInstalledPkg=0
    counterErrorInstall=0

    counterInputPkg=0

    getCurrentBranchPkg="current-version-pkgs"
    getNameFileCurrentVersionPkg="current-version-pkgs"
    getPathDirCurrentVersionPkg="/tmp/.$USER/meo/current-version"

    declare -a listOfDownloadedPkg=()
    declare -a listOfAlreadyInstalledPkg=()
    declare -a listOfInstalledPkg=()   
    declare -a listOfNotInstalledPkg=() 
    declare -a listOfErrorInstallingPkg=() 
    
    # Temporary files to save variables and arrays
    tmp_counterCloneGit=` mktemp  `
    tmp_counterNotFoundPkg=` mktemp `
    tmp_counterFlagMng=` mktemp `
    tmp_counterAlreadyInstalledPkg=` mktemp `
    #
    tmp_listOfDownloadedPkg=` mktemp `
    tmp_listOfAlreadyInstalledPkg=` mktemp `
    tmp_listOfNotInstalledPkg=` mktemp `
    

    # Call the function
    getDirPkgToInstall=` createDirPackageToInstall `

    # Shift one position
    shift 1



    # Download the packages if it exists
    ( 
        for packageUP in $@
        do
            #
            flagPackageFound=` isPackageAvailable "$packageUP" $counterInputPkg "yes" `
            flagPackageInstalledFound=` isPackageInstalled $packageUP  `
    
            #
            if [[ $flagPackageFound == "true" ]] && [[ ! ` echo "$packageUP" | grep -w -- "^$getPkgMng$" ` ]] \
                && [[ "$flagPackageInstalledFound" == "false" ]]
            then 
                
                # Call the function
                cloneSingleBranchGit "$packageUP"
                
    
                # Create a directory for the package to install in ...
                if [[ ! -e "$pkgDirectoryInMng/$packageUP" ]]
                then
                    mkdir -p "$pkgDirectoryInMng/$packageUP" 2> /dev/null
    
                else 
                    #
                    rm -fr "$pkgDirectoryInMng/$packageUP" 2> /dev/null
    
                    #
                    mkdir -p "$pkgDirectoryInMng/$packageUP" 2> /dev/null
                fi
   
                # Create a directory for the current package
                if [[ ! -e "$getDirPkgToInstall/$packageUP" ]]
                then
                    #
                    mkdir -p "$getDirPkgToInstall/$packageUP" 2> /dev/null
                fi

                # Move the package
                find "$meoTmpDirGithub/linux/package" -name "$packageUP*.deb" -type f -exec mv {} "$getDirPkgToInstall/$packageUP" \; 
    
                # Move the `info` directory of the package in ...
                find "$meoTmpDirGithub/linux/package" -maxdepth 1 -name "info" -type d -exec mv {} "$pkgDirectoryInMng/$packageUP" \;
    
                # Move the `depends` directory of the package in ...
                find "$meoTmpDirGithub/linux/package" -maxdepth 1 -name "depends" -type d -exec \
                    mv {} "$pkgDirectoryInMng/$packageUP" \;
    
    
                # Append the package to the array
                listOfDownloadedPkg+="$packageUP"
    
                #
                counterCloneGit=$(( counterCloneGit + 1 ))
    
                # Clone the file containing the current version of the packages
                if [[ $counterCloneGit -eq 1 ]]
                then
                    # Call the function
                    cloneSingleBranchGit "$getCurrentBranchPkg"
                    
                    #
                    if [[ ! -e "$getPathDirCurrentVersionPkg" ]]
                    then
                        mkdir -p "$getPathDirCurrentVersionPkg" 2> /dev/null
                    else
                        #
                        rm -rf "$getPathDirCurrentVersionPkg" 2> /dev/null
    
                        #
                        mkdir -p "$getPathDirCurrentVersionPkg" 2> /dev/null
                    fi
    
                    #
                    find  "$meoTmpDirGithub/linux/versonning" -name "$getNameFileCurrentVersionPkg" -type f -exec \
                        mv {} "$getPathDirCurrentVersionPkg"  2> /dev/null \;
                fi
    
            #
            elif [[ $flagPackageFound == "false" ]]
            then
                #
                listOfNotInstalledPkg+="$packageUP"
    
                #
                counterNotFoundPkg=$(( counterNotFoundPkg + 1 ))
    
            elif [[ "$flagPackageInstalledFound" == "true" ]]
            then
                #
                listOfAlreadyInstalledPkg+="$packageUP"
    
                #
                counterAlreadyInstalledPkg=$(( counterAlreadyInstalledPkg + 1 ))
    
            elif [[ ` echo "$packageUP" | grep -w -- "^$getPkgMng$" ` ]]
            then
                #
                counterFlagMng=$(( counterFlagMng + 1 ))
            fi

            #
            counterInputPkg=$(( counterInputPkg + 1 ))

        done


        # Save the content of variables in the temporary files 
        echo "$counterCloneGit" > "$tmp_counterCloneGit" 
        echo "$counterNotFoundPkg" > "$tmp_counterNotFoundPkg"
        echo "$counterFlagMng" > "$tmp_counterFlagMng"
        echo "$counterAlreadyInstalledPkg" > "$tmp_counterAlreadyInstalledPkg"

        # For the array
        printf "%s\n" "${listOfDownloadedPkg[@]}" > "$tmp_listOfDownloadedPkg"
        printf "%s\n" "${listOfAlreadyInstalledPkg[@]}" > "$tmp_listOfAlreadyInstalledPkg"
        printf "%s\n" "${listOfNotInstalledPkg[@]}" > "$tmp_listOfNotInstalledPkg"

    ) &
    
    
    # Call the function (for the loop above)
    spinnerAnimation $!


    # Get the content of the temporary files
    counterCloneGit=` cat "$tmp_counterCloneGit" `
    counterNotFoundPkg=` cat "$tmp_counterNotFoundPkg" `
    counterFlagMng=` cat "$tmp_counterFlagMng" `
    counterAlreadyInstalledPkg=` cat "$tmp_counterAlreadyInstalledPkg" `
    #
    listOfDownloadedPkg=( ` cat $tmp_listOfDownloadedPkg ` )
    listOfAlreadyInstalledPkg=( ` cat $tmp_listOfAlreadyInstalledPkg ` )
    listOfNotInstalledPkg=( ` cat $tmp_listOfNotInstalledPkg ` )
  

    # Installation action
    if [[ $counterCloneGit -gt 0 ]]
    then
        #
        getTheFileCurrentVersionPkg=` find "$getPathDirCurrentVersionPkg" -name "$getNameFileCurrentVersionPkg" -type f 2> /dev/null `
        
        #
        for downloadedPkg in ${listOfDownloadedPkg[@]}
        do 
            # The installer to install the dependencies of the package
            getTheInstaller=` find "$pkgDirectoryInMng/$downloadedPkg/depends" -type f -name "installer-depends.sh" `
            getTheDebPkgToInstall=` find "$getDirPkgToInstall/$downloadedPkg" -type f -name "$downloadedPkg*.deb" `

            # Installing dependencies of the current package `$downloadedPkg`
            bash "$getTheInstaller"
    
            # Install the package itself `downloadedPkg`
            dpkg --install "$getTheDebPkgToInstall"

            #
            if [[ $? -eq 0 ]]
            then

                # Call the function
                storeInslalledPkg "$getTheFileCurrentVersionPkg" "$downloadedPkg"

                #
                listOfInstalledPkg+="$downloadedPkg"

                #
                counterInstalledPkg=$(( counterInstalledPkg + 1 ))
            else
                #
                dpkg --remove "$getTheDebPkgToInstall" &> /dev/null

                #
                listOfErrorInstallingPkg+="$downloadedPkg"

                #
                counterErrorInstall=$(( counterErrorInstall + 1 ))
            fi

        done

        #
        echo ""
    fi

    #
    echo -e ""

    # If the package manager was included among the package(s) to install, cast an alert 
    if [[ $counterFlagMng -gt 0 ]]
    then
        #
        echo "~"
        echo "You can not install the \e[032;1m$getPkgMng\e[0m program itself ðŸš¨"
    fi

    
    # The list of uninstalled packages
    if [[ $counterNotFoundPkg -gt 0 ]]
    then
        #
        echo ""
        echo "~"

        for notInstalledPkg in ${listOfNotInstalledPkg[@]}
        do
            echo -e "\e[031;1m$notInstalledPkg\e[0m not found \U00274C "
        done
    fi


    # List of packages that could not be installed
    if [[ $counterErrorInstall -gt 0 ]]
    then
        #
        echo ""
        echo "~"

        for errorInstallingPkg in ${listOfErrorInstallingPkg[@]}
        do
            echo -e "\e[032;1m$errorInstallingPkg\e[0m could not be installed \U001F6AB "
        done
    fi

    
    
    # The list of package(s) already installed
    if [[ $counterAlreadyInstalledPkg -gt 0 ]]
    then
        #
        echo ""
        echo "~"

        for alreadyInstalledPkg in ${listOfAlreadyInstalledPkg[@]}
        do
            echo -e "\e[032;1m$alreadyInstalledPkg\e[0m already installed \U001F530 "
        done
    fi


    # The list of package(s) installed
    if [[ $counterInstalledPkg -gt 0 ]]
    then
        #
        echo ""
        echo "~"

        for installedPkg in ${listOfInstalledPkg[@]}
        do
            echo -e "\e[032;1m$installedPkg\e[0m installed \U002705 "
        done
    fi
   

    # Call the function
    removeGitDownloadGitAction

    # call the function
    removeDirFile "$meoTmp" "$tmp_counterCloneGit" "$tmp_counterNotFoundPkg" "$tmp_counterFlagMng" \
        "$tmp_counterAlreadyInstalledPkg" "$tmp_listOfDownloadedPkg" "$tmp_listOfAlreadyInstalledPkg" \
        "$tmp_listOfNotInstalledPkg"

    #
    if [[ $? -eq 0 ]]
    then
        exit 0
    else
        exit 1
    fi
fi

### Action based on the `install` option -> end tag[i1]





### Action based on the `update` option -> start tag[u0]

if [[ $# -eq 1 ]] && [[ $1 == "update" ]]
then
    
    # Declaration variables
    getNameOfPkg=""
    
    flagProgramInstall=""
    flagProgramNewVersion=""
    flagProgramNewRevision=""

    counterPkgNewRevision=0
    counterPkgNewVersion=0

    typeset -A tablePkgToRefreshVersion
    typeset -A tablePkgToRefreshRevision 



    # If the target file does not exist, no packages to update
    if [[ ! ( -e "$meoListInstalledPkgsPure" ) ]]
    then
        echo -e "~"
        echo -e "The job is clean, no packages to update by \e[1;032mmeo\e[0m \U002705 "

        exit 0
    fi


    # Call the function 
    refreshAvailablePkgsFile &

    # Call the function
    spinnerAnimation $!
 
    
    # Load the installed packages, their version(new or old) and the hash(new) in arrays
    while IFS= read -r lineFile
    do
        getNameOfPkg=` echo "$lineFile" | cut -d ":" -f 1 | tr -d "[[:space:]]" `

        # Call the functions
        flagProgramInstall=` isPackageInstalled $getNameOfPkg `
        flagProgramNewVersion=` isNewVersionOfPkgAvailable $getNameOfPkg `
        flagProgramNewRevision=` isNewRevisionOfPkgAvailable $getNameOfPkg `

        
        # If there is a new version of the program, then ...
        if [[ "$flagProgramInstall" == "true" ]] && [[ "$flagProgramNewVersion" == "true" ]]
        then
            # Call the function
            getNewVersionProgram=` getNewVersionPkg $getNameOfPkg `
            
            # Call the function
            getNewHashProgram=` getNewHashPkg $getNameOfPkg `
            
            # Save package info
            tablePkgToRefreshVersion[$getNameOfPkg]="$getNameOfPkg : $getNewVersionProgram : $getNewHashProgram"

            #
            counterPkgNewVersion=$(( counterPkgNewVersion + 1 ))

        elif [[ "$flagProgramNewRevision" == "true" ]] && [[ "$flagProgramInstall" == "true" ]]
        then
            # Call the function
            getVersionProgram=` getNewVersionPkg $getNameOfPkg `
            
            # Call the function
            getNewHashProgram=` getNewHashPkg $getNameOfPkg `
            
            # Save package info
            tablePkgToRefreshRevision[$getNameOfPkg]="$getNameOfPkg : $getVersionProgram : $getNewHashProgram"

            #
            counterPkgNewRevision=$(( counterPkgNewRevision + 1 ))
        fi

    done < $meoListInstalledPkgsPure
   

    
    # The action of displaying the list of packages that may be up to date
    if [[ $counterPkgNewVersion -gt 0 ]]
    then
        echo ""
        echo ""
        echo "~"
        echo -e "Here the list of package(s) can be \e[1;032mupdated\e[0m \e[1;036m\U002B06\e[0m "
        echo -e "\U001F517"

        #
        for key value in ${(kv)tablePkgToRefreshVersion}
        do
            getTheVersionPkg=` echo "$value" | awk -F " : " '{print $2}' `
            getTheHashPkg=` echo "$value" | awk -F " : " '{print $3}' `
            getThePkg=` echo "$key" `
            
            #
            echo "\e[1;032m$getThePkg\e[0m v(\e[1;036m$getTheVersionPkg\e[0m) , hash(\e[1;95m$getTheHashPkg\e[0m)"
        done
    fi


    
    # The action of displaying the list of packages that may be reviewed
    if [[ $counterPkgNewRevision -gt 0 ]]
    then
        echo ""
        echo ""
        echo "~"

        #
        if [[ $counterPkgNewRevision -eq 1 ]]
        then
            echo -e "A \e[1;032mreview\e[0m of this package is available \U001F4DD "
        else 
            echo -e "A \e[1;032mreview\e[0m of these packages are available \U001F4DD "
        fi
        
        #
        echo -e "\U001F517"

        #
        for key value in ${(kv)tablePkgToRefreshRevision}
        do
            getTheVersionPkg=` echo "$value" | awk -F " : " '{print $2}' `
            getTheHashPkg=` echo "$value" | awk -F " : " '{print $3}' `
            getThePkg=` echo "$key" `
            
            #
            echo "\e[1;032m$getThePkg\e[0m v(\e[1;036m$getTheVersionPkg\e[0m) , hash(\e[1;095m$getTheHashPkg\e[0m)"
        done
    fi
    

    #
    if [[ $counterPkgNewRevision -eq 0 ]] && [[ $counterPkgNewVersion -eq 0 ]]
    then
        echo -e "~"
        echo -e "The job is clean, no packages to update by \e[1;032mmeo\e[0m \U002705 "
    fi


   
    # Call the function
    removeGitDownloadGitAction

    exit 0
else
    if [[ $1 == "update" ]] && [[ $# -gt 1 ]]
    then
        echo "~"
        echo -e "With the \e[36;1m$1\e[0m option, there is not another argument \U001F917 "

        exit 1
    fi
fi

### Action based on the `update` option -> end tag[u0]





### Action based on the `upgrade` option -> start tag[u1]

if [[ $# -eq 1 ]] && [[ $1 == "upgrade" ]]
then
    
    # Declaration variables
    getNameOfPkg=""
    
    flagProgramInstall=""
    flagProgramNewVersion=""
    flagProgramNewRevision=""
    theTmpDirPkgs="/tmp/.$USER/meo/package-dir"
    
    getCurrentBranchPkg="current-version-pkgs"
    getNameFileCurrentVersionPkg="current-version-pkgs"
    getPathDirCurrentVersionPkg="/tmp/.$USER/meo/current-version"

    counterPkgNewVersion=0
    counterPkgNewVersionInstalled=0

    counterPkgNewRevision=0
    counterPkgNewRevisionInstalled=0

    typeset -A tablePkgToRefreshVersion
    typeset -A tablePkgToRefreshVersionInstalled

    typeset -A tablePkgToRefreshRevision
    typeset -A tablePkgToRefreshRevisionInstalled



    #
    trap "setterm --cursor on" SIGINT SIGTERM
    

    # If no packages are installed
    if [[ ` cat "$meoListInstalledPkgsPure" 2> /dev/null | wc -l | cut -d " " -f 1 ` -lt 1 ]]
    then
        echo -e "~"
        echo -e "At the time I run, no packages are installed by me \e[1;032mmeo\e[0m \U002705 "

        exit 0
    fi

    # Create a temporary directory where the content of packages will be sent
    if [[ ! -e "$theTmpDirPkgs" ]]
    then
        #
        mkdir -p "$theTmpDirPkgs" 2> /dev/null

        #
        if [[ $? -ne 0 ]]
        then
            echo "~"
            echo -e "Something is wrong \U001F9D0, make sure you have the right to write in [ /tmp ]"

            exit 1
        fi
    fi



    # Save the current position of the cursor
    tput sc

    #
    # Call the function 
    refreshAvailablePkgsFile &

    # Call the function
    spinnerAnimation $!


    # Delete the displayed lines (just above)
    tput cuu1
    tput cuu1
    tput cuu1
    tput el
    tput el
    tput el
    

    # Call the function
    cloneSingleBranchGit "$getCurrentBranchPkg" &

    # Call the function
    spinnerAnimation $!


    # Delete the displayed lines (just above)
    tput cuu1
    tput cuu1
    tput cuu1
    tput el
    tput el
    tput el
    

    # Create a temporary directory where the versions of packages will be sent
    if [[ ! -e "$getPathDirCurrentVersionPkg" ]]
    then
        mkdir -p "$getPathDirCurrentVersionPkg" 2> /dev/null
    else
        #
        rm -rf "$getPathDirCurrentVersionPkg" 2> /dev/null
    
        #
        mkdir -p "$getPathDirCurrentVersionPkg" 2> /dev/null
    fi
    
    # Move the file containing the package versions in ...
    find  "$meoTmpDirGithub/linux/versonning" -name "$getNameFileCurrentVersionPkg" -type f -exec \
        mv {} "$getPathDirCurrentVersionPkg"  2> /dev/null \;

    # Get the file containing the package versions 
    getTheFileCurrentVersionPkg=` find "$getPathDirCurrentVersionPkg" -name "$getNameFileCurrentVersionPkg" -type f 2> /dev/null `



    # Load the installed packages, their version(new or old) and the hash(new) in arrays
    while IFS= read -r lineFile
    do
        getNameOfPkg=` echo "$lineFile" | cut -d ":" -f 1 | tr -d "[[:space:]]" `

        # Call the functions
        flagProgramInstall=` isPackageInstalled $getNameOfPkg `
        flagProgramNewVersion=` isNewVersionOfPkgAvailable $getNameOfPkg `
        flagProgramNewRevision=` isNewRevisionOfPkgAvailable $getNameOfPkg `

        
        # If there is a new version of the program, then ...
        if [[ "$flagProgramInstall" == "true" ]] && [[ "$flagProgramNewVersion" == "true" ]]
        then
            # Call the function
            getNewVersionProgram=` getNewVersionPkg $getNameOfPkg `
            
            # Call the function
            getNewHashProgram=` getNewHashPkg $getNameOfPkg ` 
            
            # Call the function
            cloneSingleBranchGit "$getNameOfPkg" &

            # Call the function
            spinnerAnimation $!

            # Delete the displayed lines (just above)
            tput cuu1
            tput cuu1
            tput cuu1
            tput el
            tput el 
            tput el

            #
            getCurrentPkg=` find "$meoTmpDirGithub/linux/package" -name "$getNameOfPkg*.deb"  2> /dev/null `

            #
            mv "$getCurrentPkg" "$theTmpDirPkgs" 

            # Save package info
            tablePkgToRefreshVersion[$getNameOfPkg]="$getNameOfPkg : $getNewVersionProgram : $getNewHashProgram"

            #
            counterPkgNewVersion=$(( counterPkgNewVersion + 1 ))

        elif [[ "$flagProgramNewRevision" == "true" ]] && [[ "$flagProgramInstall" == "true" ]]
        then
            # Call the function
            getVersionProgram=` getNewVersionPkg $getNameOfPkg `
            
            # Call the function
            getNewHashProgram=` getNewHashPkg $getNameOfPkg `

            # Call the function
            cloneSingleBranchGit "$getNameOfPkg" &

            # Call the function
            spinnerAnimation $!

            # Delete the displayed lines (just above)
            tput cuu1
            tput cuu1
            tput cuu1
            tput el
            tput el
            tput el

            #
            getCurrentPkg=` find "$meoTmpDirGithub/linux/package" -name "$getNameOfPkg*.deb"  2> /dev/null `

            #
            mv "$getCurrentPkg" "$theTmpDirPkgs" 

            # Save package info
            tablePkgToRefreshRevision[$getNameOfPkg]="$getNameOfPkg : $getVersionProgram : $getNewHashProgram"

            #
            counterPkgNewRevision=$(( counterPkgNewRevision + 1 ))
        fi

    done < $meoListInstalledPkgsPure
    
    # Get back the cursor in the current position
    tput rc



    # Process of installation
    if [[ -e "$theTmpDirPkgs" ]]
    then
        # Declaration variables
        fileOfPkgReadyToInstall="$theTmpDirPkgs/file-path-deb-pkg"

        # Save the path of packages that are ready to install in a file
        find "$theTmpDirPkgs" -name "*.deb" -type f > $fileOfPkgReadyToInstall 2> /dev/null


        #
        while IFS= read -r lineFile 
        do
            #
            echo ""
            echo "~"

            # Install the `deb` package
            dpkg --install "$lineFile"

            # Check if the package was properly installed
            if [[ $? -eq 0 ]]
            then
                
                # Get the name of the package
                getThePkgName=` echo "$lineFile" | awk -F "/" '{print $NF}' | awk -F "-" '{sub(/-[^-]*$/, ""); print}' `
                
                # Call the function
                storeInslalledPkg "$getTheFileCurrentVersionPkg" "$getThePkgName"

                # Save the installed package in an array -> source array `tablePkgToRefreshVersion`
                for key value in ${(kv)tablePkgToRefreshVersion}
                do
                    if [[ ` echo "$key" | tr -d "[[:space:]]" ` == ` echo "$getThePkgName" | tr -d "[[:space:]]" ` ]]
                    then
                        #
                        tablePkgToRefreshVersionInstalled[$getThePkgName]="$value"
                        
                        #
                        counterPkgNewVersionInstalled=$(( counterPkgNewVersionInstalled + 1 ))

                        # Stop the loop
                        break 
                    fi
                done


                # Save the installed package in an array -> source array `tablePkgToRefreshRevision`
                for key value in ${(kv)tablePkgToRefreshRevision}
                do
                    if [[ ` echo "$key" | tr -d "[[:space:]]" ` == ` echo "$getThePkgName" | tr -d "[[:space:]]" ` ]]
                    then
                        #
                        tablePkgToRefreshRevisionInstalled[$getThePkgName]="$value"
                        
                        #
                        counterPkgNewRevisionInstalled=$(( counterPkgNewRevisionInstalled + 1 ))

                        # Stop the loop
                        break 
                    fi
                done
            else
                #
                dpkg --remove "$lineFile" &> /dev/null
            fi

        done < $fileOfPkgReadyToInstall
    fi



    # Some checking
    if [[ $counterPkgNewRevision -eq 0 ]] && [[ $counterPkgNewVersion -eq 0 ]]
    then
        echo -e "~"
        echo -e "All packages installed by \e[1;032mmeo\e[0m are up to date \U002705 "
    fi
    #
    if [[ $counterPkgNewVersion -ne $counterPkgNewVersionInstalled ]]
    then
        echo ""
        echo -e "~"
        echo -e "At least one package has not been \e[1;035mupdated\e[0m by the \e[1;032mmeo\e[0m program \U001F9D0 ."
        echo -e "Execute the following command to see this or these packages ."
        echo -e "\e[1;032msudo meo update\e[0m "
    fi
    #
    if [[ $counterPkgNewRevision -ne $counterPkgNewRevisionInstalled ]]
    then
        echo ""
        echo -e "~"
        echo -e "At least one package could not be \e[1;035mreviewed\e[0m by the \e[1;032mmeo\e[0m program \U001F9D0 ."
        echo -e "Execute the following command to see this or these packages ."
        echo -e "\e[1;032msudo meo update\e[0m "
    fi



    # The action of displaying the list of packages which version has been updated
    if [[ $counterPkgNewVersionInstalled -gt 0 ]]
    then
        echo ""
        echo "~"
        echo -e "Here the list of package(s) whose version has been \e[1;035mupdated\e[0m \e[1;036m\U002B06\e[0m "
        echo -e "\U001F517"

        #
        for key value in ${(kv)tablePkgToRefreshVersionInstalled}
        do
            getTheVersionPkg=` echo "$value" | awk -F " : " '{print $2}' `
            getTheHashPkg=` echo "$value" | awk -F " : " '{print $3}' `
            getThePkg=` echo "$key" `
            
            #
            echo "\e[1;032m$getThePkg\e[0m v(\e[1;036m$getTheVersionPkg\e[0m) , hash(\e[1;095m$getTheHashPkg\e[0m)"
        done
    fi


    
    # The action of displaying the list of packages that have been reviewed
    if [[ $counterPkgNewRevisionInstalled -gt 0 ]]
    then
        echo ""
        echo ""
        echo "~"

        #
        echo -e "Here the list of packages that have been \e[1;035mreviewed\e[0m \U001F4DD "
        echo -e "\U001F517"

        #
        for key value in ${(kv)tablePkgToRefreshRevisionInstalled}
        do
            getTheVersionPkg=` echo "$value" | awk -F " : " '{print $2}' `
            getTheHashPkg=` echo "$value" | awk -F " : " '{print $3}' `
            getThePkg=` echo "$key" `
            
            #
            echo "\e[1;032m$getThePkg\e[0m v(\e[1;036m$getTheVersionPkg\e[0m) , hash(\e[1;095m$getTheHashPkg\e[0m)"
        done
    fi
 

   
    # Call the function
    removeGitDownloadGitAction
    #
    removeDirFile "$theTmpDirPkgs" "$getPathDirCurrentVersionPkg"

    exit 0

elif [[ $# -gt 1 ]] && [[ $1 == "upgrade" ]]
then
    
    # Declaration variables
    getNameOfPkg=""
    
    flagProgramInstall=""
    flagProgramNewVersion=""
    flagProgramNewRevision=""
    theTmpDirPkgs="/tmp/.$USER/meo/package-dir"
    
    getCurrentBranchPkg="current-version-pkgs"
    getNameFileCurrentVersionPkg="current-version-pkgs"
    getPathDirCurrentVersionPkg="/tmp/.$USER/meo/current-version"

    counterPkgNewVersion=0
    counterPkgNewVersionInstalled=0

    counterPkgNewRevision=0
    counterPkgNewRevisionInstalled=0

    counterProgramAlreadyUpdated=0
    counterProgramNotFound=0 

    typeset -A tablePkgToRefreshVersion
    typeset -A tablePkgToRefreshVersionInstalled

    typeset -A tablePkgToRefreshRevision
    typeset -A tablePkgToRefreshRevisionInstalled

    declare -a tableProgramNotInstalled=()
    declare -a tableProgramAlreadyUpdated=()



    #
    trap "setterm --cursor on" SIGINT SIGTERM
    

    # If no packages are installed
    if [[ ` cat "$meoListInstalledPkgsPure" 2> /dev/null | wc -l | cut -d " " -f 1 ` -lt 1 ]]
    then
        echo -e "~"
        echo -e "At the time I run, no packages are installed by me \e[1;032mmeo\e[0m \U002705 "

        exit 0
    fi

    # Create a temporary directory where the content of packages will be sent
    if [[ ! -e "$theTmpDirPkgs" ]]
    then
        #
        mkdir -p "$theTmpDirPkgs" 2> /dev/null

        #
        if [[ $? -ne 0 ]]
        then
            echo "~"
            echo -e "Something is wrong \U001F9D0, make sure you have the right to write in [ /tmp ]"

            exit 1
        fi
    fi
    

    # Save the current position of the cursor
    tput sc

    # Call the function 
    refreshAvailablePkgsFile &

    # Call the function
    spinnerAnimation $!


    # Delete the displayed lines (just above)
    tput cuu1
    tput cuu1
    tput cuu1
    tput el
    tput el
    tput el
    

    # Call the function
    cloneSingleBranchGit "$getCurrentBranchPkg" &

    # Call the function
    spinnerAnimation $!


    # Delete the displayed lines (just above)
    tput cuu1
    tput cuu1
    tput cuu1
    tput el
    tput el
    tput el
    

    # Create a temporary directory where the versions of packages will be sent
    if [[ ! -e "$getPathDirCurrentVersionPkg" ]]
    then
        mkdir -p "$getPathDirCurrentVersionPkg" 2> /dev/null
    else
        #
        rm -rf "$getPathDirCurrentVersionPkg" 2> /dev/null
    
        #
        mkdir -p "$getPathDirCurrentVersionPkg" 2> /dev/null
    fi
    
    # Move the file containing the package versions in ...
    find  "$meoTmpDirGithub/linux/versonning" -name "$getNameFileCurrentVersionPkg" -type f -exec \
        mv {} "$getPathDirCurrentVersionPkg"  2> /dev/null \;

    # Get the file containing the package versions 
    getTheFileCurrentVersionPkg=` find "$getPathDirCurrentVersionPkg" -name "$getNameFileCurrentVersionPkg" -type f 2> /dev/null `

    

    # Shift the parameter `upgrade`
    shift 1



    # Load the installed packages, their version(new or old) and the hash(new) in arrays
    for pkgInput in "$@"
    do
        #
        getNameOfPkg=` echo "$pkgInput" `

        # Call the functions
        flagProgramInstall=` isPackageInstalled $getNameOfPkg `
        flagProgramNewVersion=` isNewVersionOfPkgAvailable $getNameOfPkg `
        flagProgramNewRevision=` isNewRevisionOfPkgAvailable $getNameOfPkg `

        
        # If there is a new version of the program, then ...
        if [[ "$flagProgramInstall" == "true" ]] && [[ "$flagProgramNewVersion" == "true" ]]
        then
            # Call the function
            getNewVersionProgram=` getNewVersionPkg $getNameOfPkg `
            
            # Call the function
            getNewHashProgram=` getNewHashPkg $getNameOfPkg ` 
            
            # Call the function
            cloneSingleBranchGit "$getNameOfPkg" &

            # Call the function
            spinnerAnimation $!

            # Delete the displayed lines (just above)
            tput cuu1
            tput cuu1
            tput cuu1
            tput el
            tput el 
            tput el

            #
            getCurrentPkg=` find "$meoTmpDirGithub/linux/package" -name "$getNameOfPkg*.deb"  2> /dev/null `

            #
            mv "$getCurrentPkg" "$theTmpDirPkgs" 

            # Save package info
            tablePkgToRefreshVersion[$getNameOfPkg]="$getNameOfPkg : $getNewVersionProgram : $getNewHashProgram"

            #
            counterPkgNewVersion=$(( counterPkgNewVersion + 1 ))

        elif [[ "$flagProgramNewRevision" == "true" ]] && [[ "$flagProgramInstall" == "true" ]]
        then
            # Call the function
            getVersionProgram=` getNewVersionPkg $getNameOfPkg `
            
            # Call the function
            getNewHashProgram=` getNewHashPkg $getNameOfPkg `

            # Call the function
            cloneSingleBranchGit "$getNameOfPkg" &

            # Call the function
            spinnerAnimation $!

            # Delete the displayed lines (just above)
            tput cuu1
            tput cuu1
            tput cuu1
            tput el
            tput el
            tput el

            #
            getCurrentPkg=` find "$meoTmpDirGithub/linux/package" -name "$getNameOfPkg*.deb"  2> /dev/null `

            #
            mv "$getCurrentPkg" "$theTmpDirPkgs" 

            # Save package info
            tablePkgToRefreshRevision[$getNameOfPkg]="$getNameOfPkg : $getVersionProgram : $getNewHashProgram"

            #
            counterPkgNewRevision=$(( counterPkgNewRevision + 1 ))

        elif [[ "$flagProgramInstall" == "false" ]]
        then
            #
            tableProgramNotInstalled+="$getNameOfPkg"

            #
            counterProgramNotFound=$(( counterProgramNotFound + 1 ))

        elif ( [[ "$flagProgramInstall" == "true" ]] ) && ( [[ "$flagProgramNewVersion" == "false" ]] && \
            [[ "$flagProgramNewRevision" == "false" ]] ) 
        then
            #
            tableProgramAlreadyUpdated+="$getNameOfPkg"

            #
            counterProgramAlreadyUpdated=$(( counterProgramAlreadyUpdated + 1 ))
        fi
    done
    
    # Get back the cursor in the current position
    tput rc



    # Process of installation
    if [[ -e "$theTmpDirPkgs" ]]
    then
        # Declaration variables
        fileOfPkgReadyToInstall="$theTmpDirPkgs/file-path-deb-pkg"

        # Save the path of packages that are ready to install in a file
        find "$theTmpDirPkgs" -name "*.deb" -type f > $fileOfPkgReadyToInstall 2> /dev/null


        #
        while IFS= read -r lineFile 
        do
            #
            echo ""
            echo "~"

            # Install the `deb` package
            dpkg --install "$lineFile"

            # Check if the package was properly installed
            if [[ $? -eq 0 ]]
            then
                
                # Get the name of the package
                getThePkgName=` echo "$lineFile" | awk -F "/" '{print $NF}' | awk -F "-" '{sub(/-[^-]*$/, ""); print}' `
                
                # Call the function
                storeInslalledPkg "$getTheFileCurrentVersionPkg" "$getThePkgName"

                # Save the installed package in an array -> source array `tablePkgToRefreshVersion`
                for key value in ${(kv)tablePkgToRefreshVersion}
                do
                    if [[ ` echo "$key" | tr -d "[[:space:]]" ` == ` echo "$getThePkgName" | tr -d "[[:space:]]" ` ]]
                    then
                        #
                        tablePkgToRefreshVersionInstalled[$getThePkgName]="$value"
                        
                        #
                        counterPkgNewVersionInstalled=$(( counterPkgNewVersionInstalled + 1 ))

                        # Stop the loop
                        break 
                    fi
                done


                # Save the installed package in an array -> source array `tablePkgToRefreshRevision`
                for key value in ${(kv)tablePkgToRefreshRevision}
                do
                    if [[ ` echo "$key" | tr -d "[[:space:]]" ` == ` echo "$getThePkgName" | tr -d "[[:space:]]" ` ]]
                    then
                        #
                        tablePkgToRefreshRevisionInstalled[$getThePkgName]="$value"
                        
                        #
                        counterPkgNewRevisionInstalled=$(( counterPkgNewRevisionInstalled + 1 ))

                        # Stop the loop
                        break 
                    fi
                done
            else
                #
                dpkg --install "$lineFile" &> /dev/null
            fi

        done < $fileOfPkgReadyToInstall

    fi

    
    #
    echo ""
    
    # Some checking
    if [[ $counterPkgNewRevision -eq 0 ]] && [[ $counterPkgNewVersion -eq 0 ]] && [[ $counterProgramNotFound -eq 0 ]] \
        &&  [[ $counterProgramAlreadyUpdated -eq 0 ]]
    then
        echo ""
        echo -e "~"
        echo -e "All packages installed by \e[1;032mmeo\e[0m are up to date \U002705 "
    fi
    #
    if [[ $counterPkgNewVersion -ne $counterPkgNewVersionInstalled ]]
    then
        echo ""
        echo ""
        echo -e "~"
        echo -e "At least one package has not been \e[1;035mupdated\e[0m by the \e[1;032mmeo\e[0m program \U001F9D0 ."
        echo -e "Execute the following command to see this or these packages ."
        echo -e "\e[1;032msudo meo update\e[0m "
    fi
    #
    if [[ $counterPkgNewRevision -ne $counterPkgNewRevisionInstalled ]]
    then
        echo ""
        echo ""
        echo -e "~"
        echo -e "At least one package could not be \e[1;035mreviewed\e[0m by the \e[1;032mmeo\e[0m program \U001F9D0 ."
        echo -e "Execute the following command to see this or these packages ."
        echo -e "\e[1;032msudo meo update\e[0m "
    fi



    # Not found packages
    if [[ $counterProgramNotFound -gt 0 ]]
    then
        echo ""
        echo ""
        echo "~"
        echo -e "Here the list of package(s) that \e[1;031mwere not found\e[0m \U00274C "
        echo -e "\U001F517"

        #
        for value in ${tableProgramNotInstalled[@]}
        do
            #
            echo -e "\e[1;031m$value\e[0m"
        done
    fi



    # Packages already updated
    if [[ $counterProgramAlreadyUpdated -gt 0 ]]
    then
        echo ""
        echo ""
        echo "~"
        echo -e "Here the list of package(s) that are \e[1;035malready up to date\e[0m \U002705 "
        echo -e "\U001F517"

        #
        for value in ${tableProgramAlreadyUpdated[@]}
        do
            #
            echo -e "\e[1;032m$value\e[0m v(` $value --version 2> /dev/null `) "
        done
    fi



    # The action of displaying the list of packages which version has been updated
    if [[ $counterPkgNewVersionInstalled -gt 0 ]]
    then
        echo ""
        echo ""
        echo "~"
        echo -e "Here the list of package(s) whose version has been \e[1;032mupdated\e[0m \e[1;036m\U002B06\e[0m "
        echo -e "\U001F517"

        #
        for key value in ${(kv)tablePkgToRefreshVersionInstalled}
        do
            getTheVersionPkg=` echo "$value" | awk -F " : " '{print $2}' `
            getTheHashPkg=` echo "$value" | awk -F " : " '{print $3}' `
            getThePkg=` echo "$key" `
            
            #
            echo "\e[1;032m$getThePkg\e[0m v(\e[1;036m$getTheVersionPkg\e[0m) , hash(\e[1;095m$getTheHashPkg\e[0m)"
        done
    fi


    
    # The action of displaying the list of packages that have been reviewed
    if [[ $counterPkgNewRevisionInstalled -gt 0 ]]
    then
        echo ""
        echo ""
        echo "~"

        #
        echo -e "Here the list of packages that have been \e[1;032mreviewed\e[0m \U001F4DD "
        echo -e "\U001F517"

        #
        for key value in ${(kv)tablePkgToRefreshRevisionInstalled}
        do
            getTheVersionPkg=` echo "$value" | awk -F " : " '{print $2}' `
            getTheHashPkg=` echo "$value" | awk -F " : " '{print $3}' `
            getThePkg=` echo "$key" `
            
            # 
            echo "\e[1;032m$getThePkg\e[0m v(\e[1;036m$getTheVersionPkg\e[0m) , hash(\e[1;095m$getTheHashPkg\e[0m)"
        done
    fi

   
    # Call the function
    removeGitDownloadGitAction
    #
    removeDirFile "$theTmpDirPkgs" "$getPathDirCurrentVersionPkg"

    exit 0

fi

### Action based on the `upgrade` option -> end tag[u1]





### Action based on the `remove` option -> start tag[r0]

if [[ $1 == "remove"  ]] && [[ $# -gt 1 ]]
then
    
    # Declaration variables
    flagPkgFound=""
    counterPkgRemoved=0

    declare -a listOfRemovedPkg=()
   


    #
    shift 1

    #
    for givenPkgToRemove in $@
    do
        #
        flagPkgFound=` isPackageInstalled $givenPkgToRemove `

        #
        if [[ $flagPkgFound == "true" ]] && [[ ! ` echo "$givenPkgToRemove" | grep -w -- "^meo$" ` ]]
        then

            #
            dpkg --remove $givenPkgToRemove

            if [[ $? -eq 0 ]]
            then

                listOfRemovedPkg+=$givenPkgToRemove

                #
                sed -i "/$givenPkgToRemove/d" "$meoListInstalledPkgsPure" 2> /dev/null
                    
                #
                counterPkgRemoved=$(( counterPkgRemoved + 1 ))
            fi

        elif [[ $flagPkgFound == "true" ]] && [[ ` echo "$givenPkgToRemove" | grep -w -- "^meo$" ` ]] 
        then
            
            #
            echo ""
            echo "~"
            echo "You can not remove the \e[32;1mmeo\e[0m program itself ðŸš¨"
                    
            #
            continue

        else
            echo ""
            echo "~"
            echo -e "The package \e[32;1m$givenPkgToRemove\e[0m is not installed \U001F9D0 " 
        fi
    done

    
    
    #
    if [[ $counterPkgRemoved -gt 0 ]]
    then
        echo ""
        echo ""
        echo "~"
        
        #
        for namePkgRemoved in ${listOfRemovedPkg[@]}
        do
            local getNamePkgRemoved=` echo $namePkgRemoved | tr -d "[[:space:]]" `

            if [[ "$getNamePkgRemoved" != "meo" ]]
            then
                echo -e "\e[32;1m$getNamePkgRemoved\e[0m removed \U002705 "
            fi    
        done
    fi

    # Call the function
    removeGitDownloadGitAction


    #
    exit 0

else
    # 
    if [[ $1 == "remove" ]] && [[ $# -lt 2 ]]
    then

        echo "~"
        echo -e "With the \e[36;1m$1\e[0m option, you have to give the package(s) to remove \U001F917 "

        exit 1
    fi
fi

### Action based on the `remove` option -> end tag[r0]





### Action based on the `download` option -> start tag[d0]

if [[ $1 == "download" ]] && [[ $# -gt 1 ]]
then

    # Declaration variables
    flagPkgFound=""
    getDebPkg=""
    getCurrentPath=` pwd `
    counterPkgDownloaded=0
    counterInputPkg=0

    declare -a listOfDownloadedPkg=()


    
    # Save the current position of the cursor
    tput sc 


    # Shift the `download` option
    shift 1

    

    # The downloading operations
    for pkgToDownload in $@
    do
        #
        flagPkgFound=` isPackageAvailable $pkgToDownload $counterInputPkg "yes" ` 

        #
        if [[ $flagPkgFound == "true" ]]
        then
            
            #
            cloneSingleBranchGit "$pkgToDownload" &

            # Call the function
            spinnerAnimation $!

            # Delete the displayed lines (just above)
            tput cuu1
            tput cuu1
            tput cuu1
            tput el
            tput el
            tput el

            #
            getDebPkg=` find "$meoTmpDirGithub/linux/package" -name "$pkgToDownload*.deb"  2> /dev/null `

            #
            if [[ -e "$getDebPkg"  ]]
            then
                #
                cp -ra "$getDebPkg" "$getCurrentPath" 2> /dev/null

                if [[ $? -eq 0 ]]
                then
                    #
                    counterPkgDownloaded=$(( counterPkgDownloaded + 1 ))

                    listOfDownloadedPkg+="$pkgToDownload"
                fi
            fi
        else
            # Get back the cursor in the current position 
            tput rc 

            echo ""
            echo "~"
            echo -e "The package \e[32;1m$pkgToDownload\e[0m does not exist in the \e[32;1mmeo\e[0m repository \U001F9D0 "
        fi

        #
        counterInputPkg=$(( counterInputPkg + 1 )) 

    done
    

    
    # Get back the cursor in the current position
    tput rc



    #
    if [[ $counterPkgDownloaded -gt 0 ]]
    then
        echo ""
        echo ""
        echo -e ""
        echo -e "~"

        #
        for namePkgDownloaded in ${listOfDownloadedPkg[@]}
        do
            getNamePkgDownloaded=` echo $namePkgDownloaded | tr -d "[[:space:]]" `

            if [[ -n "$getNamePkgDownloaded" ]]
            then
                echo -e "\e[32;1m$getNamePkgDownloaded\e[0m downloaded \U002705 "
            fi    
        done
    fi
    
    # Call the function
    removeGitDownloadGitAction

    exit 0
else

    if [[ $1 == "download" ]] && [[ $# -lt 2 ]]
    then

        echo "~"
        echo -e "With the \e[36;1m$1\e[0m option, you have to give the package(s) to download \U001F917 "

        exit 1
    fi
fi

### Action based on the `download` option -> end tag[d0]





### Action based on the `list` option -> start tag[l0]

if [[ $1 == "list"  ]] && [[ $# -eq 1 ]]
then

    #
    if [[ -e "$meoListAvailablePkgs" ]]
    then
        echo ""
        echo "~"
        echo -e "Here the list of \e[1;032mavailable\e[0m packages since the last execution of the "
        echo -e "command ~ \e[35;1msudo meo update\e[0m "
        echo -e "\U001F517"

        cat "$meoListAvailablePkgs" 2> /dev/null

        exit 0

    else
        echo ""
        echo "~"
        echo "Something is wrong, please reinstall the \e[32;1mmeo\e[0m program \U001F6A8"

        exit 1
    fi
else
    #
    if [[ $1 == "list" ]] && [[ $# -gt 1 ]]
    then
        echo ""
        echo "~"
        echo -e "With the \e[36;1m$1\e[0m option, there is not another argument \U001F917 "

        exit 1
    fi
fi

### Action based on the `list` option -> end tag[l0]





### Action based on the `list-installed` option -> start tag[l0]

if [[ $1 == "list-installed"  ]] && [[ $# -eq 1 ]]
then

    #
    if [[ -e "$meoListInstalledPkgsPure" ]] && [[ ` cat "$meoListInstalledPkgsPure" 2> /dev/null | wc -l | cut -d " " -f 1 ` -ge 1 ]]
    then
        echo ""
        echo "~"
        echo -e "Here the list of installed packages by the \e[35;1mmeo\e[0m program "
        echo -e "\U001F517"

        cat "$meoListInstalledPkgsPure" | \
            awk '{printf "\033[1;092m%s\033[0m : \033[1;096m%s\033[0m , \033[1;032m%s\033[0m : \033[1;036m%s\033[0m\n", $1, $3, $5, $7}' \
            2> /dev/null

        exit 0

    elif [[ -e "$meoListInstalledPkgsPure" ]] && [[ ` cat "$meoListInstalledPkgs" 2> /dev/null | wc -l | cut -d " " -f 1 ` -eq 0 ]]
    then
        echo ""
        echo "~"
        echo -e "Currently , no packages installed \U001F4BB by \e[32;1mmeo\e[0m "

        exit 0
    else
        echo ""
        echo "~"
        echo -e "Currently , no packages installed \U001F4BB by \e[32;1mmeo\e[0m "

        exit 0
    fi
else
    #
    if [[ $1 == "list-installed" ]] && [[ $# -gt 1 ]]
    then
        echo ""
        echo "~"
        echo -e "With the \e[36;1m$1\e[0m option, there is not another argument \U001F917 "

        exit 1
    fi
fi

### Action based on the `list-installed` option -> end tag[l1]





### Action based on the `search` option -> start tag[s0]

if [[ $1 == "search"  ]] && [[ $# -gt 0 ]]
then
    
    # Declaration variables
    flagPkgFound=""
    counterPkgFound=0
    counterInputPkg=0

    declare -a listOfFoundPkg=()

    typeset -A tableSearchFoundPkg



    # Shift the `search` option
    shift 1



    #
    for pkgSearched in $@
    do
        #
        flagPkgFound=` isPackageAvailable "$pkgSearched" $counterInputPkg "no" `
        getVersionOfPkg=` getNewVersionPkg $pkgSearched `
        getHashPkg=` getNewHashPkg $pkgSearched `


        #
        if [[ $flagPkgFound == "true" ]]
        then

            #
            tableSearchFoundPkg[$pkgSearched]="$pkgSearched : $getVersionOfPkg : $getHashPkg"

            #
            counterPkgFound=$(( counterPkgFound + 1 ))
        else
            echo ""
            echo "~"
            echo -e "Based on the current list available packages, that's to say since the last execution " 
            echo -e "of the command \e[1;096msudo meo update\e[0m , The package \e[031;1m$pkgSearched\e[0m you are looking for "
            echo -e "was not found in the local database of the \e[1;032mmeo\e[0m program \U001F9D0  ."
        fi

        #
        counterInputPkg=$(( counterInputPkg + 1 ))

    done


    
    #
    if [[ $counterPkgFound -gt 0 ]]
    then
        echo -e ""
        echo -e "~"

        #
        for key value in ${(kv)tableSearchFoundPkg}
        do
            getTheVersionPkg=` echo $value | awk -F " : " '{print $2}' | tr -d "[[:space:]]" `
            getTheHashPkg=` echo $value | awk -F " : " '{print $3}' | tr -d "[[:space:]]" `


            if [[ -n "$getTheVersionPkg" ]]
            then
                echo -e "\e[032;1m$key\e[0m v(\e[1;036m$getTheVersionPkg\e[0m) , hash(\e[1;095m$getTheHashPkg\e[0m) found \U002705 "
            fi    
        done

    fi


    # Call the function
    removeGitDownloadGitAction
    removeDirFile "$meoTmpDirGithub/linux"

    exit 0

else

    #
    if [[ $1 == "search" ]] && [[ $# -lt 2 ]]
    then

        echo "~"
        echo -e "With the \e[36;1m$1\e[0m option, you have to give the package(s) to search \U001F917 "

        exit 1
    fi

fi

### Action based on the `search` option -> end tag[s0]





### Action based on the `show` option -> start tag[s1]

if [[ $1 == "show" ]] && [[ $# -gt 0 ]]
then
    
    # Declaration variables
    flagPkgFound=""



    # Shift the `show` option
    shift 1



    # Action allowing to display package information
    for givenPkg in $@
    do
        flagPkgFound=` isPackageInstalled $givenPkg `

        #
        if [[ $flagPkgFound == "true" ]]
        then
            
            echo ""
            echo "~"

            dpkg-query --status $givenPkg
        else
            echo ""
            echo "~"
            echo -e "The package \e[031;1m$givenPkg\e[0m is not installed \U001F9D0 "
        fi

    done


    # Delete the given directory
    removeDirFile "$meoTmpDirGithub/linux"

    #
    exit 0
else

    #
    if [[ $1 == "show" ]] && [[ $# -lt 2 ]]
    then

        echo "~"
        echo -e "With the \e[36;1m$1\e[0m option, you have to give the package(s) to show \U001F917 "

        exit 1
    fi
fi

### Action based on the `show` option -> end tag[s1]





### Action based on the `info` option -> start tag[s2]

if [[ $1 == "info" ]] && [[ $# -eq 2 ]]
then
    
    # Declaration variables
    flagPkgFound=""
    counterInputPkg=0
    nameOfInfoPkgsBranch="share-info-pkgs"



    # Shift the `info` option
    shift 1



    # Action allowing to display package information
    for givenPkg in $@
    do
        flagPkgFound=` isPackageAvailable "$givenPkg" $counterInputPkg "no" `

        #
        if [[ $flagPkgFound == "true" ]]
        then
            # Call the function
            cloneSingleBranchGit "$nameOfInfoPkgsBranch" &

            #
            spinnerAnimation $!

            #
            getTheFileInfoPackage=` find "$meoTmpDirGithub/linux/share-info-pkgs/$givenPkg" -name "readme" -type f 2> /dev/null `

            #
            echo ""
            echo "~"

            #
            if [[ -e "$getTheFileInfoPackage" ]]
            then
                cat "$getTheFileInfoPackage" 2> /dev/null
            fi

        else
            echo ""
            echo "~"
            echo -e "Based on the current list available packages, that's to say since the last execution " 
            echo -e "of the command \e[1;096msudo meo update\e[0m , The package \e[031;1m$givenPkg\e[0m you are looking for "
            echo -e "was not found in the local database of the \e[1;032mmeo\e[0m program \U001F9D0  ."

            exit 1
        fi

        #
        counterInputPkg=$(( counterInputPkg + 1 ))

    done



    # Delete the given directory
    removeDirFile "$meoTmpDirGithub/linux"

    #
    exit 0
else

    #
    if [[ $1 == "info" ]] && [[ $# -gt 2 ]]
    then

        echo "~"
        echo -e "With the \e[36;1m$1\e[0m option, you have to only give two parameters \U001F917 "

        exit 1
    fi
fi

### Action based on the `info` option -> end tag[s2]





### Print some files linked to the options `--doc`, `--help` , `--version` --> start tag[io]

if [[ $1 == "--doc" ]] && [[ $# -eq 1 ]]
then
    #
    cat /usr/lib/meo/documentation/meo-doc 2> /dev/null

    exit 0
elif [[ $1 == "--help" ]] && [[ $# -eq 1 ]]
then
    #
    cat /usr/lib/meo/documentation/meo-help 2> /dev/null

    exit 0
elif [[ $1 == "--version" ]] && [[ $# -eq 1 ]]
then
    #
    cat /usr/lib/meo/documentation/meo-version-pure 2> /dev/null

    exit 0
fi

#
echo "~"
echo -e "Invalid request \U001F9D0 ."
exit 1

### Print some files linked to the options `--doc`, `--help` , `--version` --> end tag[io]
